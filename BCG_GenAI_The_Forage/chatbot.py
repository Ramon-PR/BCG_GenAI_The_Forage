# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_Task_2_chatbot_prototype.ipynb.

# %% auto 0
__all__ = ['get_base_dir', 'financial_chatbot', 'associate_action', 'preprocess_columns', 'best_match', 'detect_columns',
           'is_interactive']

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 2
import pandas as pd
import sys
import os
from pathlib import Path
from fastcore.all import patch
import matplotlib.pyplot as plt
import seaborn as sns

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 4
# With this I deal with notebooks and .py files to get the parent folder of the running file
# since __file__ is not defined in notebooks
def get_base_dir():
    try:
        # Works in .py scripts
        return Path(__file__).resolve().parent
    except NameError:
        # Fallback for Jupyter notebooks
        return Path(os.getcwd()).resolve()

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 8
class financial_chatbot():

    def __init__(self, file_path: Path):
        
        self._data = pd.read_csv(file_path)
        
        self._last_query: str = None
        self._current_query:str = None

        self._available_companies = self._data['Company'].unique().tolist()
        self._current_companies = []

        self._last_action = []
        self._current_action = []

        # Financial facts in data
        self._available_fin_facts = self._data.columns.difference(['Company', 'Year']).to_list()
        self._last_fin_facts = []
        self._current_fin_facts = []

        # The dictionary that will hold the final mapping
        self.action_for = {}
        self._keywords_print = set(['print', 'give me', 'show', 'display', 'output'])
        self._keywords_plot = set(['plot', 'graph', 'chart', 'visualize'])


        # Main keywords of the data
        # Words that indicate growth/percentage intent
        self._growth_keywords = {'grow', 'growth', 'percentage', 'percent', '%', 'increase', 'change', 'yoy', 'annualized'}

        # Stopwords to ignore when matching tokens (keeps domain words like 'cash' and 'flow')
        self._stopwords = {'the', 'and', 'of', 'from', 'a', 'an', 'in', 'on', 'at', 'for', 'to', 'total'}


        # Chatbot Hello
        self.print_intro()

        # Initiate some variables
        self.initiate_actions_dictionary()

    def initiate_actions_dictionary(self):
        """Defined below"""
        return

    def get_response(self, message="Your message:"):        
        self._last_query = self._current_query
        self._current_query = input(message)
        print()

        # If user wants to exit, stop the program
        if self._current_query.lower() in ["exit", "quit"]:
            raise SystemExit("Exiting chatbot.")



    def print_intro(self):
        intro_text = """
        Welcome to the Financial Chatbot!
        You can ask me questions about financial data.

        Note: All values, unless stated as percentages, 
        are expressed in millions of dollars (M$). 
        
        Type 'exit' to end the conversation.

        How can I assist you today? 
        """
        print(intro_text)
        


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 15
@patch
def parse_companies(self: financial_chatbot):
    comp = []
    for company in self._available_companies:
        if company.lower() in self._current_query.lower():
            comp.append(company)
    
    # if len comp is not zero, update current companies
    if len(comp) > 0:
        self._current_companies = comp

    return comp


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 22
def associate_action(keywords, function, dictionary):
    for keyword in keywords:
        dictionary[keyword] = function
    
    return dictionary

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 28
@patch
def initiate_actions_dictionary(self: financial_chatbot):
    # Map print and plot keywords to their respective functions
    associate_action(self._keywords_print, print, self.action_for)
    associate_action(self._keywords_plot, plt.plot, self.action_for)

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 30
@patch
def parse_action(self: financial_chatbot):
    # Separate the query into words
    query = self._current_query.lower().replace(',', '').replace('.', '').split()
    # Convert to sets for easier matching
    query_set = set(query)

    # Get all possible actions
    actions_set = set(self.action_for.keys())

    # Find common keywords between the query and the action keywords
    queried_actions = actions_set.intersection(query_set)

    # If any actions were found, update the current actions
    if len(queried_actions) > 0:
        self._last_action = self._current_action
        self._current_action = list(queried_actions)

    return queried_actions

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 34
import re
from typing import List

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 37
# will extract all the words from a string. Notice how it ignores punctuation like parentheses and %
# re.findall(r"\w+", "Total Liabilities growth (%)")
# â†’ ['Total', 'Liabilities', 'growth']
# compiling the regex once so it can be reused efficiently
_word_re = re.compile(r"\w+")

# Tokenizer that obtains all the words in a text
def _tokens(text: str) -> List[str]:
    return _word_re.findall(text.lower())



# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 38
def preprocess_columns(columns, stopwords):
    """
    Converts a list of column names into metadata dictionaries
    containing:
      - original name
      - lowercase token set (without stopwords)
      - is_growth flag
    """
    cols_meta = []
    for col in columns:
        col_lower = col.lower()
        # Flag columns that refer to growth or percentages
        is_growth_col = 'growth' in col_lower or '(%' in col_lower or '%' in col_lower

        # Remove 'growth' and punctuation for base token extraction
        base_text = (
            col_lower.replace('growth', '')
            .replace('(%', '')
            .replace(')', '')
            .replace('%', '')
        )

        # Tokenize and remove stopwords
        col_tokens = [t for t in _tokens(base_text) if t not in stopwords]

        cols_meta.append({
            'name': col,
            'tokens': set(col_tokens),
            'is_growth': is_growth_col
        })
    return cols_meta

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 40
# Prefer columns that match the growth intent; but if none produce positive score, allow the other group.
def best_match(part_tokens, cols_meta, allow_growth_flag):
    """ Return the column/fact that best matches the query 
        best (meta dictionary)
        score (int)
    """
    best = None
    best_score = 0
    
    # I scan each column (All my financial facts)
    for meta in cols_meta:

        # I check if my query and the current fact have different growth flag (Then I go to the next column/financ fact)
        if meta['is_growth'] != allow_growth_flag:
            continue

        # how many tokens are the same in my query and the financial fact?
        score = len(part_tokens & meta['tokens'])

        # If the query contains the fact give it more points (Special cases)
        if ( (meta['name'].lower() in ' '.join(part_tokens)) ):
            score += 1

        # Throughout my scan, I save the financial fact with the best score
        if score > best_score:
            best = meta
            best_score = score
            
    return best, best_score



# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 43
def detect_columns(query: str, columns: List[str], growth_words: set[str], stopwords: set[str]) -> List[str]:
    """
    1. tokenize the columns that I want to predict, remove or add metadata relevant to the prediction
    2. Divide the query in subqueries or parts (I may want multiple facts)
    3. tokenize each subquery/part
    4. For each subquery, find the best match with my set of columns/financial_facts
    """
    q = query.lower()
    # split into parts by commas or the word 'and' (word-boundary)
    parts = [p.strip() for p in re.split(r',|\band\b', q) if p.strip()]
    
    # preprocess columns into token sets and growth-flag
    cols_meta = preprocess_columns(columns, stopwords)

    results = []
    for part in parts:
        part_tokens = set(t for t in _tokens(part) if t not in stopwords)
        if not part_tokens:
            continue

        # detect if user asked for growth/percentage in this part
        wants_growth = any(k in part for k in growth_words)

        # Prefer columns that match the growth intent; but if none produce positive score, allow the other group.
        # try matching within the requested growth/non-growth group
        primary_group = best_match(part_tokens, cols_meta, wants_growth)

        # If the best_match dictionary is not empty and the score is greater than 0 
        if primary_group[0] and (primary_group[1] > 0):
            # Then I will save the name of that column with the best match
            chosen = primary_group[0]['name']
        else:
            # fallback: try the opposite group
            secondary_group = best_match(part_tokens, cols_meta, not wants_growth)
            if secondary_group[0] and secondary_group[1] > 0:
                chosen = secondary_group[0]['name']
            
            else:
                # no confident match in either group -> try any column by best score (avoid choosing on 'total' only)
                # Look in the parts withouth passing the STOPWORDS filter
                best_overall = None
                best_score = 0
                for meta in cols_meta:
                    score = len(part_tokens & meta['tokens'])
                    if meta['name'].lower() in part:
                        score += 1
                    if score > best_score:
                        best_overall = meta
                        best_score = score
                # accept only if there's at least one token matched
                chosen = best_overall['name'] if best_overall and best_score > 0 else None

        if chosen and chosen not in results:
            results.append(chosen)

    return results


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 46
@patch
def parse_financial_facts(self: financial_chatbot):
    
    assert isinstance(self._current_query, str)
    query = self._current_query

    columns = self._available_fin_facts
    growth_words = self._growth_keywords
    stopwords = self._stopwords
    
    found = detect_columns(query, columns, growth_words, stopwords)
    if len(found)>0:
        self._last_fin_facts = self._current_fin_facts
        self._current_fin_facts = found

    return found


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 50
@patch
def query_for_missing_info(self: financial_chatbot, info_type: str, prompt_message: str):
    counter = 0
    while True:
        if info_type == 'company' and len(self._current_companies) == 0:
            print(prompt_message)
            print(f"Examples {self._available_companies[:3]}")
            self.get_response()
            self.parse_companies()

        elif info_type == 'action' and len(self._current_action) == 0:

            if len(self.action_for)==0:
                self.initiate_actions_dictionary()

            print(prompt_message)
            self.get_response()
            self.parse_action()

        elif info_type == 'fact' and len(self._current_fin_facts) == 0:

            print(prompt_message)
            self.get_response()
            self.parse_financial_facts()
        else:
            break

        # Avoid too many attempts
        counter += 1
        if counter > 3:
            # print("Too many attempts. Exiting.")
            raise SystemExit("Too many attempts. Exiting.")
            # break


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 58
@patch
def _print_parsed_information(self: financial_chatbot):
    print(f"Selected companies: {self._current_companies}")
    print(f"Requested actions: {self._current_action}")
    print(f"Requested actions: {self._current_fin_facts}")

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 63
@patch
def _get_queried_data(self: financial_chatbot, last_n_years: int = 3):
    """ 
    Once I have parsed all the information in my query, I extract it from the data
    To shorten the print, you can indicate how many years should be printed.
    """

    facts = self._current_fin_facts
    filter_company = self._data["Company"].isin(self._current_companies)
    cols = ["Company","Year"] + (facts if isinstance(facts, list) else [facts])

    filtered_Data = self._data[filter_company].sort_values(
        ['Company', 'Year'],
        ascending=[True, False]
        ).groupby('Company').head(last_n_years)[cols]

    return facts, filter_company, cols, filtered_Data


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 65
@patch
def print_queried_data(self: financial_chatbot, last_n_years: int = 2):
    """ 
    It will print the filtered dataframe with the selected:
    Companies, Financial facts and the last 3 years to make it shorter
    """
    
    _, _, _, filtered_Data = self._get_queried_data(last_n_years)

    print(filtered_Data)


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 68
import matplotlib.gridspec as gridspec
import math

# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 69
@patch
def plot_queried_data(self: financial_chatbot, last_n_years:int = 3):
    
    facts, _, _, filtered_Data = self._get_queried_data(last_n_years)

    m, n = math.ceil(len(facts)/2), 2 # Number of rows and columns

    # Create a grid
    fig = plt.figure(figsize=(4*n, 3*m))
    gs = gridspec.GridSpec(m, n, figure=fig)

    axs=[]
    for i, fact in enumerate(facts):
        ax = fig.add_subplot(gs[i])
        sns.barplot(data=filtered_Data, x="Year", y=fact, hue="Company", ax=ax)
        axs.append(ax)
    plt.tight_layout()
    plt.show()


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 72
@patch
def initiate_actions_dictionary(self: financial_chatbot):
    # Map print and plot keywords to their respective functions
    associate_action(self._keywords_print, self.print_queried_data, self.action_for)
    associate_action(self._keywords_plot, self.plot_queried_data, self.action_for)



# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 79
@patch
def _chatbot_iteration(self: financial_chatbot):
    """One loop of the chatbot"""

    # First user query
    self.get_response(message=" > How can I help you? \n > (Type 'exit' to end the chat) ")

    # parse query for company
    self.parse_companies()
    # parse query for action   
    self.parse_action()
    # Parse Financial facts
    self.parse_financial_facts()

    # Ask for missing information
    self.query_for_missing_info(info_type="company", prompt_message="Please specify at least one company in your query: ")
    self.query_for_missing_info(info_type="action", prompt_message="Would you like me to print or plot the data? ")
    self.query_for_missing_info(info_type="fact", prompt_message="What financial fact are you interested in?")

    print("Summary:")
    self._print_parsed_information()

    # At this point if I don't have all the needed information, the chatbot would have stopped
    # Execute the action on the given data
    print()
    print(80*"-")
    for action_i in self._current_action:
        # print(action_i)
        self.action_for[action_i]()
        print()
        print(80*"-")


# %% ../nbs/04_Task_2_chatbot_prototype.ipynb 84
def is_interactive():
    return sys.stdin.isatty() and os.getenv("CI") != "true"

if __name__ == "__main__":
    if is_interactive():

        # Start chatbot
        print("Running in an interactive environment")

        base_dir = get_base_dir()
        path_to_data = base_dir.parent / "resources"
        file_name = "financial_data_chatbot.csv"
        file_path = path_to_data / file_name

        chatbot = financial_chatbot(file_path=file_path)

        while True:
            chatbot._chatbot_iteration()
            
    else:
        print("Skipping chatbot in non-interactive or CI environment.")

        
